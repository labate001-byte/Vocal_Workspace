import rclpy
from rclpy.node import Node
from std_msgs.msg import String
import os
import sys
import time
import contextlib
import json
import google.generativeai as genai
from dotenv import load_dotenv

load_dotenv()

@contextlib.contextmanager
def suppress_stderr():
    original_stderr_fd = os.dup(sys.stderr.fileno())
    devnull_fd = os.open(os.devnull, os.O_WRONLY)
    os.dup2(devnull_fd, sys.stderr.fileno())
    try:
        yield
    finally:
        os.dup2(original_stderr_fd, sys.stderr.fileno())
        os.close(devnull_fd)
        os.close(original_stderr_fd)

with suppress_stderr():
    import speech_recognition as sr

class VoiceInterface(Node):
    def __init__(self):
        super().__init__('voice_interface')
        self.publisher_ = self.create_publisher(String, 'voice_command', 10)
        self.recognizer = sr.Recognizer()
        
        # --- CONFIGURAZIONE PER ALTA SENSIBILIT√Ä ---
        # 1. Soglia Energia: Pi√π bassa = sente sussurri, ma pi√π rischio rumore.
        # Lasciamo dynamic=True ma abbassiamo il punto di partenza.
        self.recognizer.energy_threshold = 200 
        self.recognizer.dynamic_energy_threshold = True 
        
        # 2. Pause Threshold: CRUCIALE per lingue complesse.
        # Definisce quanto silenzio deve passare prima di considerare la frase "finita".
        # 1.2 secondi permette pause naturali mentre si cerca la parola giusta in un'altra lingua.
        self.recognizer.pause_threshold = 1.2 
        
        # 3. Non-speaking duration: quanto buffer di silenzio tenere prima e dopo.
        self.recognizer.non_speaking_duration = 0.4

        api_key = os.getenv("GEMINI_API_KEY")
        if not api_key:
            self.get_logger().error("ERRORE: API Key mancante!")
        else:
            genai.configure(api_key=api_key)
            self.model = genai.GenerativeModel('models/gemini-2.0-flash-lite')
            self.get_logger().info("Gemini Configurato (Modalit√† Alta Precisione)")

        with suppress_stderr():
            # Sample rate 16000 √® nativo per molti modelli STT, migliora la qualit√†
            self.microphone = sr.Microphone(sample_rate=16000)
        
        self.get_logger().info("In ascolto...")
        self.timer = self.create_timer(0.1, self.listen_loop)

    def ask_gemini_audio(self, audio_data):
        try:
            # --- FILTRO RIDOTTO AL MINIMO ---
            raw_data = audio_data.get_raw_data()
            # 8000 bytes a 16kHz/16bit sono solo ~0.25 secondi.
            # Scartiamo solo i "click" brevissimi, lasciamo passare quasi tutto il parlato.
            if len(raw_data) < 8000: 
                return None

            wav_bytes = audio_data.get_wav_data(convert_rate=16000, convert_width=2)

            # --- PROMPT OTTIMIZZATO FONETICAMENTE ---
            prompt = """
            Analizza l'audio fornito. Potrebbe essere in QUALSIASI lingua (Hindi, Italiano, Inglese, ecc.).
            
            Se l'audio non √® chiaro, cerca di interpretare i suoni foneticamente.
            Esempio: "idhar aao" (Hindi), "come here" (Eng), "vieni qui" (Ita).
            
            Restituisci SOLO un JSON:
            {
                "detected_language": "codice lingua (es. hi, it, en)",
                "transcription": "trascrizione fedele di ci√≤ che hai sentito",
                "translation_en": "traduzione letterale in inglese",
                "command": "VIENI_QUI" oppure "NULL"
            }
            
            Regola command:
            IMPOSTA "VIENI_QUI" SE E SOLO SE l'intento √® inequivocabilmente chiamare il robot a s√©.
            """
            
            response = self.model.generate_content([
                prompt,
                {"mime_type": "audio/wav", "data": wav_bytes}
            ])
            
            text = response.text.strip()
            if text.startswith("```json"): text = text[7:-3]
            # Gestione caso in cui il modello risponda con markdown parziale
            text = text.replace("```", "") 
            
            return json.loads(text)

        except Exception:
            # Ignoriamo silenziosamente gli errori di parsing per tenere il log pulito
            return None

    def listen_loop(self):
        with self.microphone as source:
            try:
                # Rimossa calibrazione continua per evitare loop
                
                with suppress_stderr():
                    # Aumentato timeout: ascolta segmenti pi√π lunghi (fino a 10s)
                    # per non tagliare frasi complesse in Hindi/altre lingue.
                    audio = self.recognizer.listen(source, timeout=None, phrase_time_limit=8)
                
                result = self.ask_gemini_audio(audio)
                
                if result:
                    transcription = result.get("transcription", "")
                    lang = result.get("detected_language", "?")
                    intent = result.get("command", "NULL")
                    
                    if transcription:
                        self.get_logger().info(f"üé§ [{lang}]: '{transcription}' -> {intent}")

                    if intent == "VIENI_QUI":
                        msg = String()
                        msg.data = "vieni_qui"
                        self.publisher_.publish(msg)
                        # Feedback visivo importante per sapere che ha capito
                        self.get_logger().info("üöÄ ESECUZIONE COMANDO")

                # --- THROTTLING STRATEGICO ---
                # Manteniamo una pausa minima per salvare le API, ma
                # ridotta a 1 secondo per sembrare pi√π reattivo.
                time.sleep(1.0) 

            except sr.WaitTimeoutError:
                pass 
            except Exception as e:
                # Errori critici vengono loggati, ma non fermano il nodo
                self.get_logger().warn(f"Warning loop: {e}")
                time.sleep(0.5)

def main(args=None):
    rclpy.init(args=args)
    node = VoiceInterface()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == "__main__":
    main()
